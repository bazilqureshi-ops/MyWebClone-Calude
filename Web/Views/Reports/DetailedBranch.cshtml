@using Emse.QMagic.Web.Domain.Viewmodels
@model ReportViewModel

<link href="~/assets/css/report.css" rel="stylesheet" />
<link href="~/assets/css/Chart.min.css" rel="stylesheet" />

<script src="~/assets/js/Chart.min.js"></script>
<script src="~/Scripts/report.js"></script>
<script src="~/Scripts/chartjs-label-plugin.min.js"></script>

<div class="row">
	<div class="col-xs-12 col-xs-offset-0">
		<div class="card">
			<div class="card-header">
				<div class="bussines-info-box left">
					<p>Detailed Branch Report</p>
					<p>@Model.CorporateNumber</p>
					<p>
						@{
							string branchList = "";
							for (int i = 0; i < Model.UserBranches.Count; i++)
							{
								if (i == Model.UserBranches.Count - 1) { branchList += $"{Model.UserBranches[i].Name}"; }
								else { branchList += $"{Model.UserBranches[i].Name}, "; }
							}

						}
						@branchList
					</p>
					<p>@Model.StartDate.ToLongDateString() - @Model.FinishDate.ToLongDateString()</p>
				</div>

				<div class="bussines-info-box right">
					<p>@Model.UserName</p>
					<p>@Model.UserRole</p>
					<p>@DateTime.Now.ToLongDateString() / @DateTime.Now.ToLongTimeString()</p>
				</div>
			</div>

			<form action="/Reports/ExportExcel" method="post" class="card-body">
				@for (int i = 0; i < Model.UserBranches.Count(); i++)
				{
					@Html.HiddenFor(x => Model.UserBranches[i].Name)
					@Html.HiddenFor(x => Model.UserBranches[i].Id)
					@Html.HiddenFor(x => Model.UserBranches[i].Checked)
				}

				<!-- Button Container -->
				<div class="row" id="button-area">
					<button type="button" onClick="callPrint(document);" id="printpage" class="btn btn-danger"><i class="fa fa-print"></i> Print Page </button>
					<span>&nbsp;</span>

					<button type="submit" class="btn btn-danger"><i class="fa fa-file-excel-o"></i>  Export to Excel</button>

					<button type="button" id="sign-report" class="btn btn-success" data-toggle="modal" data-target="#sign-report-modal"><i class="fa fa-pencil"></i> Sign Report </button>
				</div>

				<!-- Charts -->
				<div class="chart-container" style="margin-bottom: 2%;">
					<div class="row" id="pie-charts">

						<!-- Empty Pie Chart -->
						<div class="chart">
							<canvas id=""></canvas>
						</div>

						<!-- Branch Pie Chart -->
						<div class="chart">
							<canvas id="branch-chart"></canvas>
						</div>

						<!-- Empty Pie Chart -->
						<div class="chart">
							<canvas id=""></canvas>
						</div>

						<!-- Min Waiting Pie Chart -->
						<div class="chart">
							<canvas id="min-waiting-chart"></canvas>
						</div>

						<!-- Max Waiting Pie Chart -->
						<div class="chart">
							<canvas id="max-waiting-chart"></canvas>
						</div>

						<!-- Average Waiting Pie Chart -->
						<div class="chart">
							<canvas id="avrg-waiting-chart"></canvas>
						</div>

						<!-- Min Operation Pie Chart -->
						<div class="chart">
							<canvas id="min-operation-chart"></canvas>
						</div>

						<!-- Max Operation Pie Chart -->
						<div class="chart">
							<canvas id="max-operation-chart"></canvas>
						</div>

						<!-- Average Operation Pie Chart -->
						<div class="chart">
							<canvas id="avrg-operation-chart"></canvas>
						</div>

						<!-- Min Process Pie Chart -->
						<div class="chart">
							<canvas id="min-process-chart"></canvas>
						</div>

						<!-- Max Process Pie Chart -->
						<div class="chart">
							<canvas id="max-process-chart"></canvas>
						</div>

						<!-- Average Process Pie Chart -->
						<div class="chart">
							<canvas id="avrg-process-chart"></canvas>
						</div>
					</div>

				</div>

				<!-- Item Per Page & Search Input -->
				<select id="item-per-page">
					<option value="10">10</option>
					<option value="25">25</option>
					<option value="50">50</option>
					<option value="100">100</option>
				</select>
				<input type="text" id="search-magic-table" name="search-magic-table" placeholder="type something to search" autocomplete="off" />

				<!-- Item Table -->
				<table id="magic-table" border="1" class="magic-table col-xs-12 col-md-12 col-lg-12" cellspacing="0" width="100%">
					<thead>
						<tr>
							<th width="10%">Branch Name</th>
							<th>Total Ticket</th>
							<th>Minimum Waiting Time</th>
							<th>Maximum Waiting Time</th>
							<th>Average Waiting Time</th>
							<th>Minimum Operation Time</th>
							<th>Maximum Operation Time</th>
							<th>Average Operation Time</th>
							<th>Minimum Process Time</th>
							<th>Maximum Process Time</th>
							<th>Average Process Time</th>
						</tr>
					</thead>
					<tbody>
						<input type="hidden" name="Data[0]" value="Branch Name" />
						<input type="hidden" name="Data[0]" value="Total Ticket" />
						<input type="hidden" name="Data[0]" value="Minimum Waiting Time" />
						<input type="hidden" name="Data[0]" value="Maximum Waiting Time" />
						<input type="hidden" name="Data[0]" value="Average Waiting Time" />
						<input type="hidden" name="Data[0]" value="Minimum Operation Time" />
						<input type="hidden" name="Data[0]" value="Maximum Operation Time" />
						<input type="hidden" name="Data[0]" value="Average Operation Time" />
						<input type="hidden" name="Data[0]" value="Minimum Process Time" />
						<input type="hidden" name="Data[0]" value="Maximum Process Time" />
						<input type="hidden" name="Data[0]" value="Average Process Time" />

						@{
							for (int i = 0; i < Model.ReportProperties.Count; i++)
							{
								<tr>
									<td text="@Model.ReportProperties[i].BranchName">@Model.ReportProperties[i].BranchName</td>
									<td text="@Model.ReportProperties[i].TotalTicket">@Model.ReportProperties[i].TotalTicket</td>
									<td text="@Model.ReportProperties[i].MinWaitingTime">@Model.ReportProperties[i].MinWaitingTime</td>
									<td text="@Model.ReportProperties[i].MaxWaitingTime">@Model.ReportProperties[i].MaxWaitingTime</td>
									<td text="@Model.ReportProperties[i].AverageWaitingTime">@Model.ReportProperties[i].AverageWaitingTime</td>
									<td text="@Model.ReportProperties[i].MinOperationTime">@Model.ReportProperties[i].MinOperationTime</td>
									<td text="@Model.ReportProperties[i].MaxOperationTime">@Model.ReportProperties[i].MaxOperationTime</td>
									<td text="@Model.ReportProperties[i].AverageOperationTime">@Model.ReportProperties[i].AverageOperationTime</td>
									<td text="@Model.ReportProperties[i].MinProcessTime">@Model.ReportProperties[i].MinProcessTime</td>
									<td text="@Model.ReportProperties[i].MaxProcessTime">@Model.ReportProperties[i].MaxProcessTime</td>
									<td text="@Model.ReportProperties[i].AverageProcessTime">@Model.ReportProperties[i].AverageProcessTime</td>

									<input type="hidden" name="Data[@(i + 1)]" value="@Model.ReportProperties[i].BranchName" />
									<input type="hidden" name="Data[@(i + 1)]" value="@Model.ReportProperties[i].TotalTicket" />
									<input type="hidden" name="Data[@(i + 1)]" value="@Model.ReportProperties[i].MinWaitingTime" />
									<input type="hidden" name="Data[@(i + 1)]" value="@Model.ReportProperties[i].MaxWaitingTime" />
									<input type="hidden" name="Data[@(i + 1)]" value="@Model.ReportProperties[i].AverageWaitingTime" />
									<input type="hidden" name="Data[@(i + 1)]" value="@Model.ReportProperties[i].MinOperationTime" />
									<input type="hidden" name="Data[@(i + 1)]" value="@Model.ReportProperties[i].MaxOperationTime" />
									<input type="hidden" name="Data[@(i + 1)]" value="@Model.ReportProperties[i].AverageOperationTime" />
									<input type="hidden" name="Data[@(i + 1)]" value="@Model.ReportProperties[i].MinProcessTime" />
									<input type="hidden" name="Data[@(i + 1)]" value="@Model.ReportProperties[i].MaxProcessTime" />
									<input type="hidden" name="Data[@(i + 1)]" value="@Model.ReportProperties[i].AverageProcessTime" />
								</tr>
							}
						}


					</tbody>
				</table>

				<!-- Page Count and Result Count Info's -->
				<div class="row">
					<div id="page-info-box">
						Total Result: <span id="result-count">{ticket}</span>
						/
						Pages: <span id="page-count">{pages}</span>
					</div>

					<div id="button-container"></div>
				</div>

				<!-- Sign Report Modal -->
				<div class="modal" tabindex="-1" role="dialog" id="sign-report-modal">
					<div class="modal-dialog" role="document">
						<div class="modal-content">
							<div class="modal-header">
								<h3 class="modal-title">Add Signer</h3>

								<button type="button" class="close" data-dismiss="modal" aria-label="Close">
									<span aria-hidden="true">&times;</span>
								</button>
							</div>
							<div class="modal-body">
								<div class="row">
									<input type="text" name="signer-name" class="form-control col-xs-6 col-md-6" placeholder="Replace this text with name" value="" />
									<input type="text" name="signer-surname" class="form-control col-xs-6 col-md-6" placeholder="Replace this text with surname" value="" />
									<input type="text" name="signer-job-title" class="form-control col-xs-6 col-md-12" placeholder="Replace this text with job title (optional)" value="" />

									<button type="button" class="btn btn-primary" onclick="addSigner()">Add Signer</button>
								</div>

								<hr />

								<ul id="signer-list">
								</ul>
							</div>

							<div class="modal-footer">
								<button type="button" class="btn btn-primary" onclick="saveSigners()">Save changes</button>
								<button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
							</div>
						</div>
					</div>
				</div>

			</form>



		</div>
	</div>
</div>

<script>

	//Get Canvases
	let branchPieChart = document.getElementById('branch-chart'),
		servicePieChart = document.getElementById('service-chart'),
		segmentPieChart = document.getElementById('segment-chart'),
		serviceResultChart = document.getElementById('service-result'),

		//Half Donut Min Operation
		percentagePerBranch = [],
		minArray = [],
		maxArray = [],
		avrgArray = [],

		minOperationArray = [],
		maxOperationArray = [],
		avrgOperationArray = [],

		minProcessArray = [],
		maxProcessArray = [],
		avrgProcessArray = [];

	let trs = $('.magic-table > tbody > tr'),
		activeChartes = false;

	let percentageValue = 100 / trs.length;

	//Fill required datas into arrays
	for (let i = 0; i < trs.length; i++) {
		const row = $(trs[i]);

		if (!branchChartLabel.includes(row.children('td').eq(0).text())) {
			branchChartLabel.push(row.children('td').eq(0).text());
			branchChartData.push(row.children('td').eq(1).text());
			branchColours.push(rgba());

			minArray.push(row.children('td').eq(2).text());
			maxArray.push(row.children('td').eq(3).text());
			avrgArray.push(row.children('td').eq(4).text());

			minOperationArray.push(row.children('td').eq(5).text());
			maxOperationArray.push(row.children('td').eq(6).text());
			avrgOperationArray.push(row.children('td').eq(7).text());

			minProcessArray.push(row.children('td').eq(8).text());
			maxProcessArray.push(row.children('td').eq(9).text());
			avrgProcessArray.push(row.children('td').eq(10).text());
			percentagePerBranch.push(percentageValue);
		}

		if (!serviceChartLabel.includes(row.children('td').eq(2).text())) {
			serviceChartLabel.push(row.children('td').eq(2).text());
			serviceChartData.push($('td[text="' + $(trs[i]).children('td').eq(2).text() + '"]').length);
			serviceColours.push(rgba());
		}

		if (!segmentChartLabel.includes(row.children('td').eq(3).text())) {
			segmentChartLabel.push(row.children('td').eq(3).text());
			segmentChartData.push($('td[text="' + $(trs[i]).children('td').eq(3).text() + '"]').length);
			segmentColours.push(rgba());
		}

		if (i === trs.length - 1)
			activeChartes = true;
	}

	//Activate all charts inside this function
	const chartActive = () => {
		const instanceOfBranchChart = new Chart(branchPieChart, {
			type: 'doughnut',
			data: {
				labels: branchChartLabel,
				datasets: [{
					label: '# of Votes',
					data: branchChartData,
					backgroundColor: branchColours,
					borderWidth: 1
				}]
			},
			options: {
				plugins: {
					labels: {
						// render 'label', 'value', 'percentage', 'image' or custom function, default is 'percentage'
						render: 'percentage',

						// precision for percentage, default is 0
						precision: 2,

						// identifies whether or not labels of value 0 are displayed, default is false
						showZero: true,

						// font size, default is defaultFontSize
						fontSize: 12,

						// font color, can be color array for each data or function for dynamic color, default is defaultFontColor
						fontColor: '#fff',

						// font style, default is defaultFontStyle
						fontStyle: 'normal',

						// font family, default is defaultFontFamily
						fontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",

						// draw label in arc, default is false
						// bar chart ignores this
						arc: false,
					}
				},
				legend: {
					display: true
				},
				title: {
					display: true,
					text: 'Ticket Count Per Branch'
				},
				events: ['click'],
				animation: {
					duration: 0
				},
				responsive: true
			}
		});

		const instanceOfMinWaiting = () => {
			Chart.defaults.doughnutLabels = Chart.helpers.clone(Chart.defaults.doughnut);

			var helpers = Chart.helpers;
			var defaults = Chart.defaults;

			Chart.controllers.doughnutLabels = Chart.controllers.doughnut.extend({
				updateElement: function (arc, index, reset) {
					var _this = this;
					var chart = _this.chart,
						chartArea = chart.chartArea,
						opts = chart.options,
						animationOpts = opts.animation,
						arcOpts = opts.elements.arc,
						centerX = (chartArea.left + chartArea.right) / 2,
						centerY = (chartArea.top + chartArea.bottom) / 2,
						startAngle = opts.rotation, // non reset case handled later
						endAngle = opts.rotation, // non reset case handled later
						dataset = _this.getDataset(),
						circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : _this.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI)),
						innerRadius = reset && animationOpts.animateScale ? 0 : _this.innerRadius,
						outerRadius = reset && animationOpts.animateScale ? 0 : _this.outerRadius,
						custom = arc.custom || {},
						valueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;

					helpers.extend(arc, {
						// Utility
						_datasetIndex: _this.index,
						_index: index,

						// Desired view properties
						_model: {
							x: centerX + chart.offsetX,
							y: centerY + chart.offsetY,
							startAngle: startAngle,
							endAngle: endAngle,
							circumference: circumference,
							outerRadius: outerRadius,
							innerRadius: innerRadius,
							label: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
						},

						draw: function () {
							var ctx = this._chart.ctx,
								elementIndex = this._index,
								vm = this._view,
								sA = vm.startAngle,
								eA = vm.endAngle,
								opts = this._chart.config.options;

							var labelPos = this.tooltipPosition();
							var segmentLabel = minArray[elementIndex];

							ctx.beginPath();

							ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);
							ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);

							ctx.closePath();
							ctx.strokeStyle = vm.borderColor;
							ctx.lineWidth = vm.borderWidth;

							ctx.fillStyle = vm.backgroundColor;

							ctx.fill();
							ctx.lineJoin = 'bevel';

							if (vm.borderWidth) {
								ctx.stroke();
							}

							if (vm.circumference > 0.0015) { // Trying to hide label when it doesn't fit in segment
								ctx.beginPath();
								ctx.font = helpers.fontString(opts.defaultFontSize, opts.defaultFontStyle, opts.defaultFontFamily);
								ctx.fillStyle = "#ffffff";
								ctx.textBaseline = "top";
								ctx.textAlign = "center";

								// Round percentage in a way that it always adds up to 100%
								ctx.fillText(segmentLabel, labelPos.x, labelPos.y);
							}

						}
					});

					var model = arc._model;
					model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(dataset.backgroundColor, index, arcOpts.backgroundColor);
					model.hoverBackgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueAtIndexOrDefault(dataset.hoverBackgroundColor, index, arcOpts.hoverBackgroundColor);
					model.borderWidth = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(dataset.borderWidth, index, arcOpts.borderWidth);
					model.borderColor = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(dataset.borderColor, index, arcOpts.borderColor);

					// Set correct angles if not resetting
					if (!reset || !animationOpts.animateRotate) {
						if (index === 0) {
							model.startAngle = opts.rotation;
						} else {
							model.startAngle = _this.getMeta().data[index - 1]._model.endAngle;
						}

						model.endAngle = model.startAngle + model.circumference;
					}

					arc.pivot();
				}
			});

			var config = {
				type: 'doughnutLabels',
				data: {
					datasets: [{
						data: percentagePerBranch,
						backgroundColor: branchColours,
						label: 'Min Waiting Times'
					}],
					labels: branchChartLabel
				},
				options: {
					circumference: Math.PI,
					rotation: 1.0 * Math.PI,
					responsive: true,
					legend: { position: 'top', },
					title: { display: true, text: 'Min Waiting Times' },
					animation: { animateScale: true, animateRotate: false, duration: 0 }
				}
			};

			var ctx = document.getElementById("min-waiting-chart").getContext("2d");
			new Chart(ctx, config);
		};

		const instanceOfMaxWaiting = () => {
			Chart.defaults.doughnutLabels = Chart.helpers.clone(Chart.defaults.doughnut);

			var helpers = Chart.helpers;
			var defaults = Chart.defaults;

			Chart.controllers.doughnutLabels = Chart.controllers.doughnut.extend({
				updateElement: function (arc, index, reset) {
					var _this = this;
					var chart = _this.chart,
						chartArea = chart.chartArea,
						opts = chart.options,
						animationOpts = opts.animation,
						arcOpts = opts.elements.arc,
						centerX = (chartArea.left + chartArea.right) / 2,
						centerY = (chartArea.top + chartArea.bottom) / 2,
						startAngle = opts.rotation, // non reset case handled later
						endAngle = opts.rotation, // non reset case handled later
						dataset = _this.getDataset(),
						circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : _this.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI)),
						innerRadius = reset && animationOpts.animateScale ? 0 : _this.innerRadius,
						outerRadius = reset && animationOpts.animateScale ? 0 : _this.outerRadius,
						custom = arc.custom || {},
						valueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;

					helpers.extend(arc, {
						// Utility
						_datasetIndex: _this.index,
						_index: index,

						// Desired view properties
						_model: {
							x: centerX + chart.offsetX,
							y: centerY + chart.offsetY,
							startAngle: startAngle,
							endAngle: endAngle,
							circumference: circumference,
							outerRadius: outerRadius,
							innerRadius: innerRadius,
							label: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
						},

						draw: function () {
							var ctx = this._chart.ctx,
								elementIndex = this._index,
								vm = this._view,
								sA = vm.startAngle,
								eA = vm.endAngle,
								opts = this._chart.config.options;

							var labelPos = this.tooltipPosition();
							var segmentLabel = maxArray[elementIndex];

							ctx.beginPath();

							ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);
							ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);

							ctx.closePath();
							ctx.strokeStyle = vm.borderColor;
							ctx.lineWidth = vm.borderWidth;

							ctx.fillStyle = vm.backgroundColor;

							ctx.fill();
							ctx.lineJoin = 'bevel';

							if (vm.borderWidth) {
								ctx.stroke();
							}

							if (vm.circumference > 0.0015) { // Trying to hide label when it doesn't fit in segment
								ctx.beginPath();
								ctx.font = helpers.fontString(opts.defaultFontSize, opts.defaultFontStyle, opts.defaultFontFamily);
								ctx.fillStyle = "#ffffff";
								ctx.textBaseline = "top";
								ctx.textAlign = "center";

								// Round percentage in a way that it always adds up to 100%
								ctx.fillText(segmentLabel, labelPos.x, labelPos.y);
							}

						}
					});

					var model = arc._model;
					model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(dataset.backgroundColor, index, arcOpts.backgroundColor);
					model.hoverBackgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueAtIndexOrDefault(dataset.hoverBackgroundColor, index, arcOpts.hoverBackgroundColor);
					model.borderWidth = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(dataset.borderWidth, index, arcOpts.borderWidth);
					model.borderColor = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(dataset.borderColor, index, arcOpts.borderColor);

					// Set correct angles if not resetting
					if (!reset || !animationOpts.animateRotate) {
						if (index === 0) {
							model.startAngle = opts.rotation;
						} else {
							model.startAngle = _this.getMeta().data[index - 1]._model.endAngle;
						}

						model.endAngle = model.startAngle + model.circumference;
					}

					arc.pivot();
				}
			});

			var config = {
				type: 'doughnutLabels',
				data: {
					datasets: [{
						data: percentagePerBranch,
						backgroundColor: branchColours,
						label: 'Max Waiting Times'
					}],
					labels: branchChartLabel
				},
				options: {
					circumference: Math.PI,
					rotation: 1.0 * Math.PI,
					responsive: true,
					legend: { position: 'top', },
					title: { display: true, text: 'Max Waiting Times' },
					animation: { animateScale: true, animateRotate: false, duration: 0 }
				}
			};

			var ctx = document.getElementById("max-waiting-chart").getContext("2d");
			new Chart(ctx, config);
		};

		const instanceOfAvrgWaiting = () => {
			Chart.defaults.doughnutLabels = Chart.helpers.clone(Chart.defaults.doughnut);

			var helpers = Chart.helpers;
			var defaults = Chart.defaults;

			Chart.controllers.doughnutLabels = Chart.controllers.doughnut.extend({
				updateElement: function (arc, index, reset) {
					var _this = this;
					var chart = _this.chart,
						chartArea = chart.chartArea,
						opts = chart.options,
						animationOpts = opts.animation,
						arcOpts = opts.elements.arc,
						centerX = (chartArea.left + chartArea.right) / 2,
						centerY = (chartArea.top + chartArea.bottom) / 2,
						startAngle = opts.rotation, // non reset case handled later
						endAngle = opts.rotation, // non reset case handled later
						dataset = _this.getDataset(),
						circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : _this.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI)),
						innerRadius = reset && animationOpts.animateScale ? 0 : _this.innerRadius,
						outerRadius = reset && animationOpts.animateScale ? 0 : _this.outerRadius,
						custom = arc.custom || {},
						valueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;

					helpers.extend(arc, {
						// Utility
						_datasetIndex: _this.index,
						_index: index,

						// Desired view properties
						_model: {
							x: centerX + chart.offsetX,
							y: centerY + chart.offsetY,
							startAngle: startAngle,
							endAngle: endAngle,
							circumference: circumference,
							outerRadius: outerRadius,
							innerRadius: innerRadius,
							label: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
						},

						draw: function () {
							var ctx = this._chart.ctx,
								elementIndex = this._index,
								vm = this._view,
								sA = vm.startAngle,
								eA = vm.endAngle,
								opts = this._chart.config.options;

							var labelPos = this.tooltipPosition();
							var segmentLabel = avrgArray[elementIndex];

							ctx.beginPath();

							ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);
							ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);

							ctx.closePath();
							ctx.strokeStyle = vm.borderColor;
							ctx.lineWidth = vm.borderWidth;

							ctx.fillStyle = vm.backgroundColor;

							ctx.fill();
							ctx.lineJoin = 'bevel';

							if (vm.borderWidth) {
								ctx.stroke();
							}

							if (vm.circumference > 0.0015) { // Trying to hide label when it doesn't fit in segment
								ctx.beginPath();
								ctx.font = helpers.fontString(opts.defaultFontSize, opts.defaultFontStyle, opts.defaultFontFamily);
								ctx.fillStyle = "#ffffff";
								ctx.textBaseline = "top";
								ctx.textAlign = "center";

								// Round percentage in a way that it always adds up to 100%
								ctx.fillText(segmentLabel, labelPos.x, labelPos.y);
							}

						}
					});

					var model = arc._model;
					model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(dataset.backgroundColor, index, arcOpts.backgroundColor);
					model.hoverBackgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueAtIndexOrDefault(dataset.hoverBackgroundColor, index, arcOpts.hoverBackgroundColor);
					model.borderWidth = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(dataset.borderWidth, index, arcOpts.borderWidth);
					model.borderColor = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(dataset.borderColor, index, arcOpts.borderColor);

					// Set correct angles if not resetting
					if (!reset || !animationOpts.animateRotate) {
						if (index === 0) {
							model.startAngle = opts.rotation;
						} else {
							model.startAngle = _this.getMeta().data[index - 1]._model.endAngle;
						}

						model.endAngle = model.startAngle + model.circumference;
					}

					arc.pivot();
				}
			});

			var config = {
				type: 'doughnutLabels',
				data: {
					datasets: [{
						data: percentagePerBranch,
						backgroundColor: branchColours,
						label: 'Average Waiting Times'
					}],
					labels: branchChartLabel
				},
				options: {
					circumference: Math.PI,
					rotation: 1.0 * Math.PI,
					responsive: true,
					legend: { position: 'top', },
					title: { display: true, text: 'Average Waiting Times' },
					animation: { animateScale: true, animateRotate: false, duration: 0 }
				}
			};

			var ctx = document.getElementById("avrg-waiting-chart").getContext("2d");
			new Chart(ctx, config);
		};

		const instanceOfMinOperation = () => {
			Chart.defaults.doughnutLabels = Chart.helpers.clone(Chart.defaults.doughnut);

			var helpers = Chart.helpers;
			var defaults = Chart.defaults;

			Chart.controllers.doughnutLabels = Chart.controllers.doughnut.extend({
				updateElement: function (arc, index, reset) {
					var _this = this;
					var chart = _this.chart,
						chartArea = chart.chartArea,
						opts = chart.options,
						animationOpts = opts.animation,
						arcOpts = opts.elements.arc,
						centerX = (chartArea.left + chartArea.right) / 2,
						centerY = (chartArea.top + chartArea.bottom) / 2,
						startAngle = opts.rotation, // non reset case handled later
						endAngle = opts.rotation, // non reset case handled later
						dataset = _this.getDataset(),
						circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : _this.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI)),
						innerRadius = reset && animationOpts.animateScale ? 0 : _this.innerRadius,
						outerRadius = reset && animationOpts.animateScale ? 0 : _this.outerRadius,
						custom = arc.custom || {},
						valueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;

					helpers.extend(arc, {
						// Utility
						_datasetIndex: _this.index,
						_index: index,

						// Desired view properties
						_model: {
							x: centerX + chart.offsetX,
							y: centerY + chart.offsetY,
							startAngle: startAngle,
							endAngle: endAngle,
							circumference: circumference,
							outerRadius: outerRadius,
							innerRadius: innerRadius,
							label: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
						},

						draw: function () {
							var ctx = this._chart.ctx,
								elementIndex = this._index,
								vm = this._view,
								sA = vm.startAngle,
								eA = vm.endAngle,
								opts = this._chart.config.options;

							var labelPos = this.tooltipPosition();
							var segmentLabel = minOperationArray[elementIndex];

							ctx.beginPath();

							ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);
							ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);

							ctx.closePath();
							ctx.strokeStyle = vm.borderColor;
							ctx.lineWidth = vm.borderWidth;

							ctx.fillStyle = vm.backgroundColor;

							ctx.fill();
							ctx.lineJoin = 'bevel';

							if (vm.borderWidth) {
								ctx.stroke();
							}

							if (vm.circumference > 0.0015) { // Trying to hide label when it doesn't fit in segment
								ctx.beginPath();
								ctx.font = helpers.fontString(opts.defaultFontSize, opts.defaultFontStyle, opts.defaultFontFamily);
								ctx.fillStyle = "#ffffff";
								ctx.textBaseline = "top";
								ctx.textAlign = "center";

								// Round percentage in a way that it always adds up to 100%
								ctx.fillText(segmentLabel, labelPos.x, labelPos.y);
							}

						}
					});

					var model = arc._model;
					model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(dataset.backgroundColor, index, arcOpts.backgroundColor);
					model.hoverBackgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueAtIndexOrDefault(dataset.hoverBackgroundColor, index, arcOpts.hoverBackgroundColor);
					model.borderWidth = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(dataset.borderWidth, index, arcOpts.borderWidth);
					model.borderColor = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(dataset.borderColor, index, arcOpts.borderColor);

					// Set correct angles if not resetting
					if (!reset || !animationOpts.animateRotate) {
						if (index === 0) {
							model.startAngle = opts.rotation;
						} else {
							model.startAngle = _this.getMeta().data[index - 1]._model.endAngle;
						}

						model.endAngle = model.startAngle + model.circumference;
					}

					arc.pivot();
				}
			});

			var config = {
				type: 'doughnutLabels',
				data: {
					datasets: [{
						data: percentagePerBranch,
						backgroundColor: branchColours,
						label: 'Min Operation Times'
					}],
					labels: branchChartLabel
				},
				options: {
					circumference: Math.PI,
					rotation: 1.0 * Math.PI,
					responsive: true,
					legend: { position: 'top', },
					title: { display: true, text: 'Min Operation Times' },
					animation: { animateScale: true, animateRotate: false, duration: 0 }
				}
			};

			var ctx = document.getElementById("min-operation-chart").getContext("2d");
			new Chart(ctx, config);
		};

		const instanceOfMaxOperation = () => {
			Chart.defaults.doughnutLabels = Chart.helpers.clone(Chart.defaults.doughnut);

			var helpers = Chart.helpers;
			var defaults = Chart.defaults;

			Chart.controllers.doughnutLabels = Chart.controllers.doughnut.extend({
				updateElement: function (arc, index, reset) {
					var _this = this;
					var chart = _this.chart,
						chartArea = chart.chartArea,
						opts = chart.options,
						animationOpts = opts.animation,
						arcOpts = opts.elements.arc,
						centerX = (chartArea.left + chartArea.right) / 2,
						centerY = (chartArea.top + chartArea.bottom) / 2,
						startAngle = opts.rotation, // non reset case handled later
						endAngle = opts.rotation, // non reset case handled later
						dataset = _this.getDataset(),
						circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : _this.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI)),
						innerRadius = reset && animationOpts.animateScale ? 0 : _this.innerRadius,
						outerRadius = reset && animationOpts.animateScale ? 0 : _this.outerRadius,
						custom = arc.custom || {},
						valueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;

					helpers.extend(arc, {
						// Utility
						_datasetIndex: _this.index,
						_index: index,

						// Desired view properties
						_model: {
							x: centerX + chart.offsetX,
							y: centerY + chart.offsetY,
							startAngle: startAngle,
							endAngle: endAngle,
							circumference: circumference,
							outerRadius: outerRadius,
							innerRadius: innerRadius,
							label: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
						},

						draw: function () {
							var ctx = this._chart.ctx,
								elementIndex = this._index,
								vm = this._view,
								sA = vm.startAngle,
								eA = vm.endAngle,
								opts = this._chart.config.options;

							var labelPos = this.tooltipPosition();
							var segmentLabel = maxOperationArray[elementIndex];

							ctx.beginPath();

							ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);
							ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);

							ctx.closePath();
							ctx.strokeStyle = vm.borderColor;
							ctx.lineWidth = vm.borderWidth;

							ctx.fillStyle = vm.backgroundColor;

							ctx.fill();
							ctx.lineJoin = 'bevel';

							if (vm.borderWidth) {
								ctx.stroke();
							}

							if (vm.circumference > 0.0015) { // Trying to hide label when it doesn't fit in segment
								ctx.beginPath();
								ctx.font = helpers.fontString(opts.defaultFontSize, opts.defaultFontStyle, opts.defaultFontFamily);
								ctx.fillStyle = "#ffffff";
								ctx.textBaseline = "top";
								ctx.textAlign = "center";

								// Round percentage in a way that it always adds up to 100%
								ctx.fillText(segmentLabel, labelPos.x, labelPos.y);
							}

						}
					});

					var model = arc._model;
					model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(dataset.backgroundColor, index, arcOpts.backgroundColor);
					model.hoverBackgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueAtIndexOrDefault(dataset.hoverBackgroundColor, index, arcOpts.hoverBackgroundColor);
					model.borderWidth = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(dataset.borderWidth, index, arcOpts.borderWidth);
					model.borderColor = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(dataset.borderColor, index, arcOpts.borderColor);

					// Set correct angles if not resetting
					if (!reset || !animationOpts.animateRotate) {
						if (index === 0) {
							model.startAngle = opts.rotation;
						} else {
							model.startAngle = _this.getMeta().data[index - 1]._model.endAngle;
						}

						model.endAngle = model.startAngle + model.circumference;
					}

					arc.pivot();
				}
			});

			var config = {
				type: 'doughnutLabels',
				data: {
					datasets: [{
						data: percentagePerBranch,
						backgroundColor: branchColours,
						label: 'Max Waiting Times'
					}],
					labels: branchChartLabel
				},
				options: {
					circumference: Math.PI,
					rotation: 1.0 * Math.PI,
					responsive: true,
					legend: { position: 'top', },
					title: { display: true, text: 'Max Waiting Times' },
					animation: { animateScale: true, animateRotate: false, duration: 0 }
				}
			};

			var ctx = document.getElementById("max-operation-chart").getContext("2d");
			new Chart(ctx, config);
		};

		const instanceOfAvrgOperation = () => {
			Chart.defaults.doughnutLabels = Chart.helpers.clone(Chart.defaults.doughnut);

			var helpers = Chart.helpers;
			var defaults = Chart.defaults;

			Chart.controllers.doughnutLabels = Chart.controllers.doughnut.extend({
				updateElement: function (arc, index, reset) {
					var _this = this;
					var chart = _this.chart,
						chartArea = chart.chartArea,
						opts = chart.options,
						animationOpts = opts.animation,
						arcOpts = opts.elements.arc,
						centerX = (chartArea.left + chartArea.right) / 2,
						centerY = (chartArea.top + chartArea.bottom) / 2,
						startAngle = opts.rotation, // non reset case handled later
						endAngle = opts.rotation, // non reset case handled later
						dataset = _this.getDataset(),
						circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : _this.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI)),
						innerRadius = reset && animationOpts.animateScale ? 0 : _this.innerRadius,
						outerRadius = reset && animationOpts.animateScale ? 0 : _this.outerRadius,
						custom = arc.custom || {},
						valueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;

					helpers.extend(arc, {
						// Utility
						_datasetIndex: _this.index,
						_index: index,

						// Desired view properties
						_model: {
							x: centerX + chart.offsetX,
							y: centerY + chart.offsetY,
							startAngle: startAngle,
							endAngle: endAngle,
							circumference: circumference,
							outerRadius: outerRadius,
							innerRadius: innerRadius,
							label: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
						},

						draw: function () {
							var ctx = this._chart.ctx,
								elementIndex = this._index,
								vm = this._view,
								sA = vm.startAngle,
								eA = vm.endAngle,
								opts = this._chart.config.options;

							var labelPos = this.tooltipPosition();
							var segmentLabel = avrgOperationArray[elementIndex];

							ctx.beginPath();

							ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);
							ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);

							ctx.closePath();
							ctx.strokeStyle = vm.borderColor;
							ctx.lineWidth = vm.borderWidth;

							ctx.fillStyle = vm.backgroundColor;

							ctx.fill();
							ctx.lineJoin = 'bevel';

							if (vm.borderWidth) {
								ctx.stroke();
							}

							if (vm.circumference > 0.0015) { // Trying to hide label when it doesn't fit in segment
								ctx.beginPath();
								ctx.font = helpers.fontString(opts.defaultFontSize, opts.defaultFontStyle, opts.defaultFontFamily);
								ctx.fillStyle = "#ffffff";
								ctx.textBaseline = "top";
								ctx.textAlign = "center";

								// Round percentage in a way that it always adds up to 100%
								ctx.fillText(segmentLabel, labelPos.x, labelPos.y);
							}

						}
					});

					var model = arc._model;
					model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(dataset.backgroundColor, index, arcOpts.backgroundColor);
					model.hoverBackgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueAtIndexOrDefault(dataset.hoverBackgroundColor, index, arcOpts.hoverBackgroundColor);
					model.borderWidth = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(dataset.borderWidth, index, arcOpts.borderWidth);
					model.borderColor = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(dataset.borderColor, index, arcOpts.borderColor);

					// Set correct angles if not resetting
					if (!reset || !animationOpts.animateRotate) {
						if (index === 0) {
							model.startAngle = opts.rotation;
						} else {
							model.startAngle = _this.getMeta().data[index - 1]._model.endAngle;
						}

						model.endAngle = model.startAngle + model.circumference;
					}

					arc.pivot();
				}
			});

			var config = {
				type: 'doughnutLabels',
				data: {
					datasets: [{
						data: percentagePerBranch,
						backgroundColor: branchColours,
						label: 'Average Waiting Times'
					}],
					labels: branchChartLabel
				},
				options: {
					circumference: Math.PI,
					rotation: 1.0 * Math.PI,
					responsive: true,
					legend: { position: 'top', },
					title: { display: true, text: 'Average Waiting Times' },
					animation: { animateScale: true, animateRotate: false, duration: 0 }
				}
			};

			var ctx = document.getElementById("avrg-operation-chart").getContext("2d");
			new Chart(ctx, config);
		};

		const instanceOfMinProcess = () => {
			Chart.defaults.doughnutLabels = Chart.helpers.clone(Chart.defaults.doughnut);

			var helpers = Chart.helpers;
			var defaults = Chart.defaults;

			Chart.controllers.doughnutLabels = Chart.controllers.doughnut.extend({
				updateElement: function (arc, index, reset) {
					var _this = this;
					var chart = _this.chart,
						chartArea = chart.chartArea,
						opts = chart.options,
						animationOpts = opts.animation,
						arcOpts = opts.elements.arc,
						centerX = (chartArea.left + chartArea.right) / 2,
						centerY = (chartArea.top + chartArea.bottom) / 2,
						startAngle = opts.rotation, // non reset case handled later
						endAngle = opts.rotation, // non reset case handled later
						dataset = _this.getDataset(),
						circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : _this.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI)),
						innerRadius = reset && animationOpts.animateScale ? 0 : _this.innerRadius,
						outerRadius = reset && animationOpts.animateScale ? 0 : _this.outerRadius,
						custom = arc.custom || {},
						valueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;

					helpers.extend(arc, {
						// Utility
						_datasetIndex: _this.index,
						_index: index,

						// Desired view properties
						_model: {
							x: centerX + chart.offsetX,
							y: centerY + chart.offsetY,
							startAngle: startAngle,
							endAngle: endAngle,
							circumference: circumference,
							outerRadius: outerRadius,
							innerRadius: innerRadius,
							label: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
						},

						draw: function () {
							var ctx = this._chart.ctx,
								elementIndex = this._index,
								vm = this._view,
								sA = vm.startAngle,
								eA = vm.endAngle,
								opts = this._chart.config.options;

							var labelPos = this.tooltipPosition();
							var segmentLabel = minProcessArray[elementIndex];

							ctx.beginPath();

							ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);
							ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);

							ctx.closePath();
							ctx.strokeStyle = vm.borderColor;
							ctx.lineWidth = vm.borderWidth;

							ctx.fillStyle = vm.backgroundColor;

							ctx.fill();
							ctx.lineJoin = 'bevel';

							if (vm.borderWidth) {
								ctx.stroke();
							}

							if (vm.circumference > 0.0015) { // Trying to hide label when it doesn't fit in segment
								ctx.beginPath();
								ctx.font = helpers.fontString(opts.defaultFontSize, opts.defaultFontStyle, opts.defaultFontFamily);
								ctx.fillStyle = "#ffffff";
								ctx.textBaseline = "top";
								ctx.textAlign = "center";

								// Round percentage in a way that it always adds up to 100%
								ctx.fillText(segmentLabel, labelPos.x, labelPos.y);
							}

						}
					});

					var model = arc._model;
					model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(dataset.backgroundColor, index, arcOpts.backgroundColor);
					model.hoverBackgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueAtIndexOrDefault(dataset.hoverBackgroundColor, index, arcOpts.hoverBackgroundColor);
					model.borderWidth = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(dataset.borderWidth, index, arcOpts.borderWidth);
					model.borderColor = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(dataset.borderColor, index, arcOpts.borderColor);

					// Set correct angles if not resetting
					if (!reset || !animationOpts.animateRotate) {
						if (index === 0) {
							model.startAngle = opts.rotation;
						} else {
							model.startAngle = _this.getMeta().data[index - 1]._model.endAngle;
						}

						model.endAngle = model.startAngle + model.circumference;
					}

					arc.pivot();
				}
			});

			var config = {
				type: 'doughnutLabels',
				data: {
					datasets: [{
						data: percentagePerBranch,
						backgroundColor: branchColours,
						label: 'Min Process Times'
					}],
					labels: branchChartLabel
				},
				options: {
					circumference: Math.PI,
					rotation: 1.0 * Math.PI,
					responsive: true,
					legend: { position: 'top', },
					title: { display: true, text: 'Min Process Times' },
					animation: { animateScale: true, animateRotate: false, duration: 0 }
				}
			};

			var ctx = document.getElementById("min-process-chart").getContext("2d");
			new Chart(ctx, config);
		};

		const instanceOfMaxProcess = () => {
			Chart.defaults.doughnutLabels = Chart.helpers.clone(Chart.defaults.doughnut);

			var helpers = Chart.helpers;
			var defaults = Chart.defaults;

			Chart.controllers.doughnutLabels = Chart.controllers.doughnut.extend({
				updateElement: function (arc, index, reset) {
					var _this = this;
					var chart = _this.chart,
						chartArea = chart.chartArea,
						opts = chart.options,
						animationOpts = opts.animation,
						arcOpts = opts.elements.arc,
						centerX = (chartArea.left + chartArea.right) / 2,
						centerY = (chartArea.top + chartArea.bottom) / 2,
						startAngle = opts.rotation, // non reset case handled later
						endAngle = opts.rotation, // non reset case handled later
						dataset = _this.getDataset(),
						circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : _this.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI)),
						innerRadius = reset && animationOpts.animateScale ? 0 : _this.innerRadius,
						outerRadius = reset && animationOpts.animateScale ? 0 : _this.outerRadius,
						custom = arc.custom || {},
						valueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;

					helpers.extend(arc, {
						// Utility
						_datasetIndex: _this.index,
						_index: index,

						// Desired view properties
						_model: {
							x: centerX + chart.offsetX,
							y: centerY + chart.offsetY,
							startAngle: startAngle,
							endAngle: endAngle,
							circumference: circumference,
							outerRadius: outerRadius,
							innerRadius: innerRadius,
							label: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
						},

						draw: function () {
							var ctx = this._chart.ctx,
								elementIndex = this._index,
								vm = this._view,
								sA = vm.startAngle,
								eA = vm.endAngle,
								opts = this._chart.config.options;

							var labelPos = this.tooltipPosition();
							var segmentLabel = maxProcessArray[elementIndex];

							ctx.beginPath();

							ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);
							ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);

							ctx.closePath();
							ctx.strokeStyle = vm.borderColor;
							ctx.lineWidth = vm.borderWidth;

							ctx.fillStyle = vm.backgroundColor;

							ctx.fill();
							ctx.lineJoin = 'bevel';

							if (vm.borderWidth) {
								ctx.stroke();
							}

							if (vm.circumference > 0.0015) { // Trying to hide label when it doesn't fit in segment
								ctx.beginPath();
								ctx.font = helpers.fontString(opts.defaultFontSize, opts.defaultFontStyle, opts.defaultFontFamily);
								ctx.fillStyle = "#ffffff";
								ctx.textBaseline = "top";
								ctx.textAlign = "center";

								// Round percentage in a way that it always adds up to 100%
								ctx.fillText(segmentLabel, labelPos.x, labelPos.y);
							}

						}
					});

					var model = arc._model;
					model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(dataset.backgroundColor, index, arcOpts.backgroundColor);
					model.hoverBackgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueAtIndexOrDefault(dataset.hoverBackgroundColor, index, arcOpts.hoverBackgroundColor);
					model.borderWidth = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(dataset.borderWidth, index, arcOpts.borderWidth);
					model.borderColor = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(dataset.borderColor, index, arcOpts.borderColor);

					// Set correct angles if not resetting
					if (!reset || !animationOpts.animateRotate) {
						if (index === 0) {
							model.startAngle = opts.rotation;
						} else {
							model.startAngle = _this.getMeta().data[index - 1]._model.endAngle;
						}

						model.endAngle = model.startAngle + model.circumference;
					}

					arc.pivot();
				}
			});

			var config = {
				type: 'doughnutLabels',
				data: {
					datasets: [{
						data: percentagePerBranch,
						backgroundColor: branchColours,
						label: 'Max Process Times'
					}],
					labels: branchChartLabel
				},
				options: {
					circumference: Math.PI,
					rotation: 1.0 * Math.PI,
					responsive: true,
					legend: { position: 'top', },
					title: { display: true, text: 'Max Process Times' },
					animation: { animateScale: true, animateRotate: false, duration: 0 }
				}
			};

			var ctx = document.getElementById("max-process-chart").getContext("2d");
			new Chart(ctx, config);
		};

		const instanceOfAvrgProcess = () => {
			Chart.defaults.doughnutLabels = Chart.helpers.clone(Chart.defaults.doughnut);

			var helpers = Chart.helpers;
			var defaults = Chart.defaults;

			Chart.controllers.doughnutLabels = Chart.controllers.doughnut.extend({
				updateElement: function (arc, index, reset) {
					var _this = this;
					var chart = _this.chart,
						chartArea = chart.chartArea,
						opts = chart.options,
						animationOpts = opts.animation,
						arcOpts = opts.elements.arc,
						centerX = (chartArea.left + chartArea.right) / 2,
						centerY = (chartArea.top + chartArea.bottom) / 2,
						startAngle = opts.rotation, // non reset case handled later
						endAngle = opts.rotation, // non reset case handled later
						dataset = _this.getDataset(),
						circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : _this.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI)),
						innerRadius = reset && animationOpts.animateScale ? 0 : _this.innerRadius,
						outerRadius = reset && animationOpts.animateScale ? 0 : _this.outerRadius,
						custom = arc.custom || {},
						valueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;

					helpers.extend(arc, {
						// Utility
						_datasetIndex: _this.index,
						_index: index,

						// Desired view properties
						_model: {
							x: centerX + chart.offsetX,
							y: centerY + chart.offsetY,
							startAngle: startAngle,
							endAngle: endAngle,
							circumference: circumference,
							outerRadius: outerRadius,
							innerRadius: innerRadius,
							label: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
						},

						draw: function () {
							var ctx = this._chart.ctx,
								elementIndex = this._index,
								vm = this._view,
								sA = vm.startAngle,
								eA = vm.endAngle,
								opts = this._chart.config.options;

							var labelPos = this.tooltipPosition();
							var segmentLabel = avrgProcessArray[elementIndex];

							ctx.beginPath();

							ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);
							ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);

							ctx.closePath();
							ctx.strokeStyle = vm.borderColor;
							ctx.lineWidth = vm.borderWidth;

							ctx.fillStyle = vm.backgroundColor;

							ctx.fill();
							ctx.lineJoin = 'bevel';

							if (vm.borderWidth) {
								ctx.stroke();
							}

							if (vm.circumference > 0.0015) { // Trying to hide label when it doesn't fit in segment
								ctx.beginPath();
								ctx.font = helpers.fontString(opts.defaultFontSize, opts.defaultFontStyle, opts.defaultFontFamily);
								ctx.fillStyle = "#ffffff";
								ctx.textBaseline = "top";
								ctx.textAlign = "center";

								// Round percentage in a way that it always adds up to 100%
								ctx.fillText(segmentLabel, labelPos.x, labelPos.y);
							}

						}
					});

					var model = arc._model;
					model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(dataset.backgroundColor, index, arcOpts.backgroundColor);
					model.hoverBackgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueAtIndexOrDefault(dataset.hoverBackgroundColor, index, arcOpts.hoverBackgroundColor);
					model.borderWidth = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(dataset.borderWidth, index, arcOpts.borderWidth);
					model.borderColor = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(dataset.borderColor, index, arcOpts.borderColor);

					// Set correct angles if not resetting
					if (!reset || !animationOpts.animateRotate) {
						if (index === 0) {
							model.startAngle = opts.rotation;
						} else {
							model.startAngle = _this.getMeta().data[index - 1]._model.endAngle;
						}

						model.endAngle = model.startAngle + model.circumference;
					}

					arc.pivot();
				}
			});

			var config = {
				type: 'doughnutLabels',
				data: {
					datasets: [{
						data: percentagePerBranch,
						backgroundColor: branchColours,
						label: 'Average Process Times'
					}],
					labels: branchChartLabel
				},
				options: {
					circumference: Math.PI,
					rotation: 1.0 * Math.PI,
					responsive: true,
					legend: { position: 'top', },
					title: { display: true, text: 'Average Process Times' },
					animation: { animateScale: true, animateRotate: false, duration: 0 }
				}
			};

			var ctx = document.getElementById("avrg-process-chart").getContext("2d");
			new Chart(ctx, config);
		};

		//Call back functions
		instanceOfMinWaiting();
		instanceOfMaxWaiting();
		instanceOfAvrgWaiting();

		instanceOfMinOperation();
		instanceOfMaxOperation();
		instanceOfAvrgOperation();

		instanceOfMinProcess();
		instanceOfMaxProcess();
		instanceOfAvrgProcess();
	};

	activeChartes ? chartActive() : '';




</script>